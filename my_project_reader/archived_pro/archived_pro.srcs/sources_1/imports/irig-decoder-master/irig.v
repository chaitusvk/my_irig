//
// IRIG-B decoder for WR-LEN White Rabbit node
//
// Given a 10 MHz clock and unmodulated IRIG-B
// input, provides binary timestamp indicating
// the absolute time and a PPS signal.
//
// John Kelley
// WIPAC / Univ. of Wisconsin-Madison
// jkelley@icecube.wisc.edu
//
module irig(input         clk_10mhz,
            input         rst,
            input         each_cycle,
            input         large_cycle,
            output        mark,
            output         d_0,
            output         d_1,
            output[3:0]    state,    
            output  pps_out,
            output [3:0] sec_data_u,
            output [3:0] sec_data_t,
            output [3:0] min_data_u,
            output [3:0] min_data_t,
            output [3:0] hour_data_u,
            output [3:0] hour_data_t,
            output [3:0] day_data_u,
            output [3:0] day_data_t,
            output [3:0] day_data_h
            );
    
    wire                  irig_d0;
    wire                  irig_d1;
    wire                  irig_mark;
    wire                  irig_garbage;
    
    
    

    // Decode the IRIG-B width-encoded bits
    // into data 0, data 1, and mark signals
    /*irig_width_decode id1(.clk(clk_10mhz),
                          .rst(rst),
                          .irigb(irigb),
                          .irig_mark(irig_mark),
                          .irig_d0(irig_d0),
                          .irig_d1(irig_d1));*/
     irig_symbol_decode id1(
                              .each_cycle(each_cycle),
                              .large_cycle(large_cycle),
                              .clk(clk_10mhz),
                              .rst(rst),
                              //.start_of_symbl(start_of_symbl),
                              //.end_of_symbl(end_of_symbl),
                              .mark(irig_mark),
                              .irig_d0(irig_d0),
                              .irig_d1(irig_d1)
                              //.irig_garbage(irig_garbage)
                              );

    // Lock onto and track the IRIG-B "states"
    // separated by mark signals.  Grab the BCD and binary
    // bit values and send them to the timestamp block.
    /*irig_state is1(.clk(clk_10mhz),
                   .rst(rst),
                   .end_of_symbl(end_of_symbl),
                   .irig_d0(irig_d0),
                   .irig_d1(irig_d1),
                   .irig_mark(irig_mark),
                   .state_var(state),
                   .pps_gate(pps_gate),
                   .ts_select(ts_select),
                   .ts_finish(ts_finish),
                   .bit_idx(bit_idx),
                   .digit_idx(digit_idx),
                   .bit_value(bit_value)); */
                   
      state_irig IS2 (
                       .clk(clk_10mhz),    // Clock
                       .rst(rst), // Reset
                       .irig_d0(irig_d0),  // d0
                       .irig_d1(irig_d1),
                       .irig_mark(irig_mark),
                       .irig_garbage(1'b0),
                       .pps(pps_out),
                       .state_out(state),
                       .sec_data_u(sec_data_u),
                       .sec_data_t(sec_data_t),
                       .min_data_u(min_data_u),
                       .min_data_t(min_data_t),
                       .hour_data_u(hour_data_u),
                       .hour_data_t(hour_data_t),
                       .day_data_u(day_data_u),
                       .day_data_t(day_data_t),
                       .day_data_h(day_data_h)
                       
                   );

    

    // PPS signal is generated by gating the IRIG signal
    // during the start marker.  Technically this should be a
    // negedge-registered signal, but it is directly
    // generated from the change in the IRIG signal itself
    // so will be set up in time. 
    /*output        mark,
                output         d_0,
                output         d_1,*/
    assign mark = irig_mark;
    assign d_0 = irig_d0;
    assign d_1 = irig_d1;
    
endmodule


