//
// IRIG-B decoder for WR-LEN White Rabbit node
//
// Given a 10 MHz clock and unmodulated IRIG-B
// input, provides binary timestamp indicating
// the absolute time and a PPS signal.
//
// John Kelley
// WIPAC / Univ. of Wisconsin-Madison
// jkelley@icecube.wisc.edu
//
module irig(input         clk_10mhz,
            input         rst,
            input         each_cycle,
            input         large_cycle,
            output        mark,
            output         d_0,
            output         d_1,
            output[3:0]    state,    
            output        pps,
            //output [8:0] sec_out
            output [3:0]     sec_data_u,
            output [2:0]     sec_data_t,
            output [3:0]     min_data_u,
            output [2:0]     min_data_t,
            output [3:0]     hrs_data_u,
            output [1:0]     hrs_data_t
            );
    
    wire                  irig_d0;
    wire                  irig_d1;
    wire                  irig_mark;
    wire                  pps_gate;
    
    
    wire                 start_of_symbl;
    wire                 end_of_symbl;
    
    //wire [8:0] sec_data;
   // wire [3:0]     sec_data_u;
   // wire [2:0]     sec_data_t;

    // Decode the IRIG-B width-encoded bits
    // into data 0, data 1, and mark signals
    /*irig_width_decode id1(.clk(clk_10mhz),
                          .rst(rst),
                          .irigb(irigb),
                          .irig_mark(irig_mark),
                          .irig_d0(irig_d0),
                          .irig_d1(irig_d1));*/
     irig_symbol_decode id1(
                              .each_cycle(each_cycle),
                              .large_cycle(large_cycle),
                              .clk(clk_10mhz),
                              .rst(rst),
                              .start_of_symbl(start_of_symbl),
                              .end_of_symbl(end_of_symbl),
                              .mark(irig_mark),
                              .irig_d0(irig_d0),
                              .irig_d1(irig_d1)
                              );

    // Lock onto and track the IRIG-B "states"
    // separated by mark signals.  Grab the BCD and binary
    // bit values and send them to the timestamp block.
    irig_state is1(.clk(clk_10mhz),
                   .rst(rst),
                   .end_of_symbl(end_of_symbl),
                   .irig_d0(irig_d0),
                   .irig_d1(irig_d1),
                   .irig_mark(irig_mark),
                   .state_var(state),
                   .pps_gate(pps_gate),
                   .sec_data_u(sec_data_u),
                   .sec_data_t(sec_data_t),
                   .min_data_u(min_data_u),
                   .min_data_t(min_data_t),
                   .hrs_data_u(hrs_data_u),
                   .hrs_data_t(hrs_data_t)
                   );

    // From the BCD and binary bit values, generate
    // the timestamps of the previous whole second
   /* irig_timestamp it1(.clk(clk_10mhz),
                       .rst(rst),
                       .bit_idx(bit_idx),
                       .digit_idx(digit_idx),
                       .bit_value(bit_value),
                       .ts_select(ts_select),
                       .ts_finish(ts_finish),
                       .ts_second(ts_second),
                       .ts_minute(ts_minute),
                       .ts_hour(ts_hour),
                       .ts_day(ts_day),
                       .ts_year(ts_year),
                       .ts_sec_day(ts_sec_day));*/

    // PPS signal is generated by gating the IRIG signal
    // during the start marker.  Technically this should be a
    // negedge-registered signal, but it is directly
    // generated from the change in the IRIG signal itself
    // so will be set up in time. 
    assign pps = each_cycle & pps_gate;
    assign mark = irig_mark;
    assign d_0 = irig_d0;
    assign d_1 = irig_d1;
   // assign sec_out = sec_data;

endmodule


